#!/bin/bash
# vim: foldmethod=marker
# [WIP] work in progress
# debug and help {{{
if [[ $1 = -x ]];then set -x;trap read debug;shift;fi

[[ $1 == -h ]] && echo "
    || This script HAS to be run from within path of dev branch that is to be merged.
    || Script is very interactive, still it automates quite a few things:
    || * Jira comment is scaffolded for you.
    || * Apps are launched for you (browser pointing to Jira, etc).
    || * You are reminded of manual procedures that needs to be done.
    || Since there are many unexpected paths, there process state will be written to tmp/file,
    || so merge process may be interrupted for resolving conflicts, and continued from where you left off.
    ||
    |@ Arguments:
    |  [1]{upstream} space separated affected branches that the merge will cascade thru (in that order)
    |? Example usage:
    |$ $(basename $0) '3.4 3.6 3.8 4.0'
    |& Dependencies: fzf, meld
" && exit
# }}}
# Prose on argument validation start {{{
[[ -z $1 ]] && $(basename $0) -h && echo "!! upsteam needed" && exit 1
[[ -z "$(zbx.resolve.branch dev)" ]] && $(basename $0) -h && echo "!! could not resolve ticket from $PWD" && exit
tags_arr=(`svn list $(zbx.resolve.remote)/branches`)
for t in $1; do
    if [[ ! " ${tags_arr[@]} " =~ " ${t}/ " ]]; then
        printf '!!"%s" is not in upstream:\n\t%s\n' "${t}" "${tags_arr[*]}"
        exit 1
    fi
done
# }}} Validation end
jiralogin=talbergs
ticket=$(zbx.resolve.branch dev)
jiramsg="Fixed in:"
# Few routines {{{
jiramsg(){
    jiramsg=$(printf '%s\n* *%s* r%s' "${jiramsg}" $(zbx.version $1) $2);
}
fetchrev() {
    echo -n $(svn info $(zbx.resolve.base --branch $1) \
        | grep "Revi" \
        | awk '{print $2}')
}
preval() {
    echo "$(tput bold)${1}$(tput sgr 0)"
    read -p "Sure to run this line?"
    # eval "$1" &>/dev/null
    eval "$1"
    # TODO provide a way to edit before submit
    # TODO save in bash_history regardless of $?
}
bump_ticket() {
    preval "svn merge $(zbx.resolve.base --branch $1 --use-remote) $(zbx.resolve.base --branch $ticket)"
    echo "$(tput setaf 125)$((merge++))) UPDATED $ticket to latest from $1 $(tput sgr 0)"
    read -p "Had no conflicts? Else you are on your own."
    msg="$(zbx.flags --) [$ticket] updated to latest from ^/$(zbx.resolve.base --use-relative --branch $1); no conflicts"
    preval "svn commit -m \"$msg\""
    echo "$(tput setaf 125)$((merge++))) COMMITED: $ticket $(tput sgr 0)"
}
caretaker(){
    echo "Local merge $1 -> $2 is done."
    echo "Before commit, this reminds you to test $2 web."
    read -p "
    [s]scaffold enviromnent for manual test
    [d]preview diff
    [w]i tested all, and im ready to continue
    [q]bail out
    "
    # TODO enviroment: zbx.rise command
}
merge=1
changelog_eddited=
merge() {
    # TODO secure rev numbers; remove unneeded updates
    # svn up $(zbx.resolve.base --branch $1)
    # echo "$(tput setaf 125)$((merge++))) UPDATED: $(zbx.resolve.base --branch $1)$(tput sgr 0)"
    svn up $(zbx.resolve.base --branch $2)
    echo "$(tput setaf 125)$((merge++))) UPDATED: $(zbx.resolve.base --branch $2)$(tput sgr 0)"
    if [[ -z $rev ]];then
        bump_ticket $2
        preval "svn merge $(zbx.resolve.base --branch $ticket --use-remote) $(zbx.resolve.base --branch $2)"
        echo "$(tput setaf 125)$((merge++))) MERGED: $ticket (YOUR WORK) -> $2 $(tput sgr 0)"
        read -p "Had no conflicts? Else you are on your own."
    else
        if [[ -z $changelog_eddited ]];then
            sed -i "/Changes for $(zbx.resolve.version)/$exactline" ./ChangeLog
            $EDITOR ./ChangeLog
            changelog_eddited=1
        fi
        preval "svn merge $(zbx.resolve.base --branch $1 --use-remote)@$rev $(zbx.resolve.base --branch $2)"
        echo "$(tput setaf 125)$((merge++))) MERGED (cherry-pick: $rev): $1 -> $2 $(tput sgr 0)"
        caretaker
        preval "svn commit $(zbx.resolve.base --branch $2) -m \"ASD\""
        echo "$(tput setaf 125)$((merge++))) COMMITED: $2 $(tput sgr 0)"
    fi
    rev=$(fetchrev $2)
    jiramsg $2 $rev
}
# }}}

mrch=$(cat ChangeLog | grep  "^Changes for" | head -n 1 | awk '{print $3}')
read -p "
Provide changelog row that will be used for commit messages and changelog.
In changelog section $(tput bold)$mrch$(tput sgr 0) this will be written
$(tput bold)$(zbx.flags --) $chprefix <MSG> ($jiralogin)$(tput sgr 0)
~bare issue meaning statement please <MSG>: " changelogdesc

# TODO flags should be extracted from absolute diff
exactline="$(zbx.flags --) $changelogdesc ($jiralogin)"
mergmsg="$(zbx.flags --) $changelogdesc"

from=$ticket
for t in $1; do
    merge $from $t
    from=$t
done
merge $from trunk

echo "---Jira public comment---
$jiramsg"


# TODO
# removing merged development branch
